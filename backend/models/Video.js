const mongoose = require('mongoose');

// Timeline event schema for flagged moments
const timelineEventSchema = new mongoose.Schema({
  start: { type: Number, required: true }, // seconds
  end: { type: Number, required: true },
  category: { type: String, required: true },
  score: { type: Number, required: true, min: 0, max: 1 },
  excerpt: String,
  note: String,
  thumbnailPath: String
}, { _id: false });

// Transcript snippet schema
const transcriptSnippetSchema = new mongoose.Schema({
  time: { type: Number, required: true }, // seconds
  text: { type: String, required: true },
  flagged: { type: Boolean, default: false },
  category: String
}, { _id: false });

// Analysis scores schema
const analysisScoresSchema = new mongoose.Schema({
  nudity: { type: Number, default: 0, min: 0, max: 1 },
  violence: { type: Number, default: 0, min: 0, max: 1 },
  profanity: { type: Number, default: 0, min: 0, max: 1 },
  hate_speech: { type: Number, default: 0, min: 0, max: 1 },
  sexual_content: { type: Number, default: 0, min: 0, max: 1 },
  drug_use: { type: Number, default: 0, min: 0, max: 1 },
  weapons: { type: Number, default: 0, min: 0, max: 1 },
  overall_confidence: { type: Number, default: 0, min: 0, max: 1 }
}, { _id: false });

// Model versions schema for provenance
const modelVersionsSchema = new mongoose.Schema({
  vision: String,
  asr: String,
  text_analysis: String,
  llm: String
}, { _id: false });

const videoSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Please provide a title'],
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  originalName: {
    type: String,
    trim: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  orgId: {
    type: mongoose.Schema.Types.ObjectId,
    required: [true, 'Organization ID is required'],
    index: true
  },
  status: {
    type: String,
    enum: ['uploading', 'processing', 'extracting', 'analyzing_frames', 'transcribing', 'analyzing_text', 'summarizing', 'processed', 'completed', 'failed'],
    default: 'uploading'
  },
  
  // Overall classification
  overall: {
    type: String,
    enum: ['safe', 'neutral', 'flagged', 'review'],
    default: 'neutral'
  },
  
  // Legacy sensitivity field (maps to overall)
  sensitivity: {
    type: String,
    enum: ['safe', 'flagged', 'public', 'internal', 'confidential', 'restricted'],
    default: 'internal'
  },
  
  // Analysis scores
  scores: {
    type: analysisScoresSchema,
    default: () => ({})
  },
  
  // Timeline of flagged moments
  timeline: {
    type: [timelineEventSchema],
    default: []
  },
  
  // Transcript with timestamps
  transcript: {
    type: [transcriptSnippetSchema],
    default: []
  },
  
  // Full transcript text
  fullTranscript: {
    type: String,
    default: ''
  },
  
  // Human-readable description generated by LLM
  humanDescription: {
    type: String,
    default: ''
  },
  
  // Recommended action
  recommendedAction: {
    type: String,
    enum: ['publish', 'age_restrict', 'manual_review', 'remove', 'pending'],
    default: 'pending'
  },
  
  // Model versions used for analysis (provenance)
  modelVersions: {
    type: modelVersionsSchema,
    default: () => ({})
  },
  
  // Extracted keyframe paths
  keyframes: [{
    path: String,
    timestamp: Number,
    analysis: mongoose.Schema.Types.Mixed
  }],
  
  // Audio file path
  audioPath: String,
  
  url: {
    type: String,
    required: true
  },
  size: {
    type: Number,
    required: true
  },
  filename: {
    type: String,
    required: true
  },
  filepath: {
    type: String,
    required: true
  },
  mimetype: {
    type: String,
    required: true
  },
  duration: {
    type: Number // in seconds
  },
  resolution: {
    width: Number,
    height: Number
  },
  processingProgress: {
    type: Number,
    default: 0,
    min: 0,
    max: 100
  },
  processingStage: {
    type: String,
    default: ''
  },
  processingError: {
    type: String,
    default: ''
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Compound index for multi-tenant queries
videoSchema.index({ orgId: 1, userId: 1 });
videoSchema.index({ orgId: 1, status: 1 });
videoSchema.index({ orgId: 1, overall: 1 });
videoSchema.index({ orgId: 1, recommendedAction: 1 });

videoSchema.pre('save', function() {
  this.updatedAt = Date.now();
});

module.exports = mongoose.model('Video', videoSchema);
